---
title: Object Orientation
---

##More on Objects

###Object Based Programming Recap

We saw last lesson how to 

* create our own classes
* store data with member variables
* add functionality with member functions
* initialise objects with constructors

###Class design

The concepts we have introduced are common between different object oriented languages.
Thus, when we design our program using these concepts, we can think at an architectural level,
independent of language syntax.

```python
class Particle(object):
    def __init__(self, position, velocity):
       self.position=position
       self.velocity=velocity
    def move(self, delta_t):
       self.position+= self.velocity*delta_t
```

``` cpp
class Particle {
    std::vector<double> position;
    std::vector<double> velocity;
    Particle(std::vector<double> position, std::vector<double> velocity);
    move(double delta_t);
}
```

``` fortran
type particle
    real :: position
    real :: velocity
  contains
    procedure :: init
    procedure :: move
end type particle
```

###UML

UML is a conventional diagrammatic notation used to describe "class structures" and other higher level
aspects of software design.

Computer scientists get worked up about formal correctness of UML diagrams and learning the conventions precisely.
Working programmers can still benefit from using UML to describe their designs.

###UML for objects

UML represents class members and methods like this:

![Basic class UML](session06/figures/basic)

(The above diagram is generated by the following:

```
http://yuml.me/diagram/boring/class/[Particle|position;velocity|move()]
```

using the [YUML](http://yuml.me/) online UML drawing tool.

##Information Hiding

Sometimes, our design for a program would be broken if users start messing around with variables we don't want them to change.

Robust class design requires consideration of which subroutines are intended for users to use, and which are internal.
Languages provide features to implement this: access control. 

In python, we use leading underscores to control whether member variables and methods can be accessed from outside the class.

```python
class MyClass(object):
    def __private_method(self): pass
    def _private_method(self): pass
    def public_method(self):
        self.__secret_method # OK

MyClass().__private_method() # Generates error
MyClass()._private_method() # Works, but forbidden by convention
MyClass().public_method() # OK
```

###Property accessors

Python provides a mechanism to make functions appear to be variables. This can be used if you want to
change the way a class is implemented without changing the interface:

Members should be private and accessed by accessors, so that
should the storage change, client code doesn't need to change.

```python
class Person(object):
    def __init__(self):
        self.name = "James Hetherington"

assert(Person().name == "James Hetherington")
```

becomes:

```python
class Person(object):
    def __init__(self):
        self._first = "James"
        self._second = "Hetherington"

    @property
    def name(self):
        return self._first + " " + self._second

assert(Person().name == "James Hetherington")
```

Note that the code behaves the same way to the outside user.
The implementation detail is hidden by private variables.
In languages without this feature, such as C++, it is best to always
make data private, and always
access data through functions:

``` python
class Person(object):
    def __init__(self):
        self._name = "James Hetherington"

    def name(self):
        return self._name

assert(Person().name() == "James Hetherington")
```

But in Python this is unnecessary.

###Class Members

*Class*, or *static* members, belong to the class as a whole, and are shared between instances.

``` python
class Counted(object):
    number_created=0
    def __init__(self):
        Counted.number_created+=1

    @classmethod
    def howMany(cls):
        return cls.number_created

Counted.howMany() # 0
x=Counted()
Counted.howMany() # 1
z=[Counted() for x in range(5)]
Counted.howMany() # 6 
```

### Object-based vs Object-Oriented

So far we have seen only object-based programming, not object-oriented programming.

Using Objects doesn't mean your code is object-oriented.

To understand object-oriented programming, we need to introduce **polymorphism** and **inheritance**.

##Inheritance

* Inheritance allows related classes to share code
* Inheritance allows a program to reflect the *ontology* of kinds of thing in a program.

###Ontology and inheritance

* A bird is a kind of animal
* An eagle is a kind of bird
* A starling is also a kind of bird

* All animals can be born and die
* Only birds can fly (Ish.)
* Only eagles hunt
* Only starlings flock

###Inheritance in python

``` python
class Animal(object):
    def beBorn(self): print "I exist"
    def die(self): print "Argh!"

class Bird(Animal):
    def fly(self): print "Whee!"

class Eagle(Bird):
    def hunt(self): print "I'm gonna eatcha!"

Eagle().beBorn()
Eagle().hunt()
```

###Inheritance terminology

* A *derived class* _derives_ from a *base class*
* A *subclass* _inherits_ from a *superclass*

(These are different terms for the same thing.)

* Eagle is a subclass of the Animal superclass.
* Animal is the base class of the Eagle derived class

###Inheritance and constructors

``` python
class Animal(object):
    def __init__(self, age):
        self.age=age

class Person(Animal):
    def __init__(self, age, name):
        super(Person, self).__init__(age)
        self.name=name
```

###Inheritance UML diagrams

UML shows inheritance with an open triangular arrow pointing from subclass to superclass.

![Bird inheritance diagram](session07/figures/inheritance)

###Aggregation vs Inheritance

If one object *has* or *owns* one or more objects, this is *not* inheritance.

For example, in my solution to the Boids task from last week, the overal Model owned several Boids,
and each Boid owned two 2-vectors, one for position and one for velocity.

###Aggregation in UML

The Boids situation can be represented thus:

![Boid aggregation diagram](session07/figures/aggregation)

The open diamond indicates **Aggregation**, the closed diamond **composition**.
(A given boid might belong to multiple models, a given position vector is forever part of the corresponding Boid.)

The asterisk represents cardinality, a model may contain multiple Boids.

###Refactoring to inheritance

Smell: Repeated code between two classes which are both ontologically subtypes of something

Before:

``` python
class Person(object):
    def __init__(self, age, job): 
        self.age = age
        self.job = job

    def birthday(self): 
        self.age += 1

class Pet(object):
    def __init__(self, age, owner): 
        self.age = age
        self.owner = owner

    def birthday(self): 
        self.age += 1
```

After:

``` python
class Animal(object):
    def __init__(self, age): 
        self.age = age

    def birthday(self): 
        self.age += 1

class Person(Animal):
    def __init__(self, age, job):
        self.job = job
        super(Person, self).__init__(age)
```

##Polymorphism

###Polymorphism

``` python
class Dog(object):
    def noise(self):
        return "Bark"

class Cat(object):
    def noise(self):
        return "Miaow"

animals=[Dog(), Dog(), Cat(), Pig(), Cow(), Cat()]
for animal in animals:
    print animal.noise()
```

This will print "Bark Bark Miaow Oink Moo Miaow"

If two classes support the same method, but it does different things for the two classes, 
then if an object is of an unknown class, calling the method will invoke the version for
whatever class the instance is an instance of.

###Polymorphism and Inheritance

Often, polymorphism uses multiple derived classes with a common base class.
However, duck typing in Python means that all that is required is that the 
types support a common **Concept** (Such as iterable, or container, or, in this case, the
Noisy concept.)

A common base class is used where there is a likely **default** that you want several
of the derived classes to have.

``` cpp
class Animal(object):
    def noise(self): return "I don't make a noise."

class Dog(Animal):
    def noise(self): return "Bark"

class Worm(Animal):
    pass

class Poodle(Animal):
    pass

animals=[Dog(), Worm(), Pig(), Cow(), Poodle()]
for animal in animals:
    print animal.noise()
```

###Refactoring to Polymorphism

Smell: a function uses a big set of `if` statements or a `case` statement to decide what to do:

Before:

``` python
class Animal(object):
    def __init__(self,type): self.type=type
    def noise(self): 
        if self.type=="Dog":
            return "Bark"
        elif self.type=="Cat":
            return "Miaow"
        elif self.type=="Cow":
            return "Moo"
```

which is better replaced by the code above.

###Further UML

UML is a much larger diagram language than the aspects we've shown here.

* Message sequence charts show signals passing back and forth between objects ([Web Sequence Diagrams](https://www.websequencediagrams.com/))

* Entity Relationship Diagrams can be used to show more general relationships between things in a system



